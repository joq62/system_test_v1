%%% -------------------------------------------------------------------
%%% Author  : uabjle
%%% Description : dbase using dets 
%%% 
%%% Created : 10 dec 2012
%%% -------------------------------------------------------------------
-module(map_reduce). 
   
%% --------------------------------------------------------------------
%% Include files
%% --------------------------------------------------------------------
-include_lib("eunit/include/eunit.hrl").

-import(lists,[foreach/2]).

%%---------------------------------------------------------------------
%% Records for test
%%

%% --------------------------------------------------------------------
-define(TimeOut,3000).
-export([start_nodes/0]).

%% ====================================================================
%% External functions
%% ====================================================================

% --------------------------------------------------------------------
%% Function:start/0 
%% Description: Initiate the eunit tests, set upp needed processes etc
%% Returns: non
%% --------------------------------------------------------------------

% --------------------------------------------------------------------
%% Function:start/0 
%% Description: Initiate the eunit tests, set upp needed processes etc
%% Returns: non
%% --------------------------------------------------------------------
mapreduce(F1,F2,Acc0,L)->
    S=self(),
    Pid=spawn(fun()->
		      reduce(S,F1,F2,Acc0,L) end),
    receive
	{Pid,Result}->
	    Result
    end.

reduce(Parent,F1,F2,Acc0,L)->
    process_flag(trap_exit,true),
    ReducePid=self(),
    
    foreach(fun(X)->
		    spawn_link(fun()->
				       do_job(ReducePid,F1,X) end)
	    end, L),
    N=length(L),
    Dict0=dict:new(),
    Dict1=collect_replies(N,Dict0),
    Acc = dict:fold(F2, Acc0,Dict1),
    Parent!{self(),Acc}.

collect_replies(0,Dict)->
    Dict;
collect_replies(N,Dict) ->
    receive
	{Key,Value}->
	    case dict:is_key(Key,Dict) of
		true->
		    Dict1=dict:append(Key,Value,Dict),
		    collect_replies(N,Dict1);
		false ->
		    Dict1=dict:store(Key,[Value],Dict),
		    collect_replies(N,Dict1)
		end;
	{'EXIT',_,_Why} ->
	    collect_replies(N-1,Dict)
    end.
	    
do_job(ReducePid, F, X)->
    F(ReducePid,X).

start_nodes(VmIds,HostId)->
    F1 = fun start_node/2,
    F2 = fun start_node_result/1,
    ControlVmId="10250",
    L=[{ControlVmId,VmId,HostId}||VmId<-VmIds],
    Result=mapreduce(F1,F2,[],L).


start_node(Parent,{ControlVmId,VmId,HostId})->
    StartResult=case db_computer:read(HostId) of
		    []->
			{error,[eexists,HostId]};
		    [{HostId,User,PassWd,IpAddr,Port}]->
			ControlVm=list_to_atom(ControlVmId++"@"++HostId),
			ok=rpc:call(ControlVm,file,make_dir,[VmId]),
			[]=rpc:call(ControlVm,os,cmd,["erl -sname "++VmId++" -setcookie abc -detached "],2*?TimeOut),
			Vm=list_to_atom(VmId++"@"++HostId),
			R=check_started(500,Vm,10,{error,[Vm]}),
		%	io:format("VmId = ~p",[{VmId,?MODULE,?LINE}]),
		%	io:format(",  ~p~n",[{R,?MODULE,?LINE}]),
			R
		end,
    Parent!{start_node_result,StartResult}.

start_node_result(Key,Vals)->
    Vals.

node_start(HostId,VmId)->
    StartResult=case db_computer:read(HostId) of
		    []->
			{error,[eexists,HostId]};
		    [{HostId,User,PassWd,IpAddr,Port}]->
			ok=my_ssh:ssh_send(IpAddr,Port,User,PassWd,"mkdir "++VmId,2*?TimeOut),
			ok=my_ssh:ssh_send(IpAddr,Port,User,PassWd,"erl -sname "++VmId++" -setcookie abc -detached ",2*?TimeOut),
			Vm=list_to_atom(VmId++"@"++HostId),
			R=check_started(500,Vm,10,{error,[Vm]}),
		%	io:format("VmId = ~p",[{VmId,?MODULE,?LINE}]),
		%	io:format(",  ~p~n",[{R,?MODULE,?LINE}]),
%			timer:sleep(500),
			R
		end,
    StartResult.

% --------------------------------------------------------------------
%% Function:start/0 
%% Description: Initiate the eunit tests, set upp needed processes etc
%% Returns: non
%% --------------------------------------------------------------------

map_clean_node(VmIds,HostId)->
    Pids=map_clean_node_start(VmIds,HostId,[]),
 %   io:format("Pids = ~p~n",[{Pids,?MODULE,?LINE}]),
    CollectedResult=map_clean_node_collect(Pids),
 %   io:format("CollectedResult = ~p~n",[{CollectedResult,?MODULE,?LINE}]),
    ResultNodeStart=map_clean_node_reduce(CollectedResult),
    ResultNodeStart.

map_clean_node_start([],_,MapProcesses)->
    MapProcesses;
map_clean_node_start([WorkerId|T],HostId,Acc)->
    Parent=self(),
    Pid=spawn_link(fun()->clean_node(Parent,HostId,WorkerId) end),
    map_clean_node_start(T,HostId,[{WorkerId,Pid}|Acc]).
			   

map_clean_node_collect([])->
    [];
map_clean_node_collect(MapProcesses)->
    N=lists:flatlength(MapProcesses), 
    map_clean_node_collect(N,[]).

map_clean_node_collect(0,CollectedInfo)->
    CollectedInfo;
map_clean_node_collect(N,Acc) ->
    NewAcc=receive
	       {_Pid,Result}->
		   [Result|Acc]
	   after 6*?TimeOut->
		   [timeout|Acc]
    end,
    map_clean_node_collect(N-1,NewAcc).

map_clean_node_reduce(CollectedResult)->		
    CollectedResult.

clean_node(Parent,HostId,VmId)->
    % Read computer info 
    Result=case db_computer:read(HostId) of
	       []->
		   {error,[eexists,HostId]};
	       [{HostId,User,PassWd,IpAddr,Port}]->
						%	    ok=rpc:call(list_to_atom(?ControlVmId++"@"++HostId),
						%			file,del_dir_r,[VmId]),
		   rpc:call(list_to_atom(?ControlVmId++"@"++HostId),
			      os,cmd,["rm -rf "++VmId]),
		   R=rpc:call(list_to_atom(?ControlVmId++"@"++HostId),filelib,is_dir,[VmId]),
		   timer:sleep(300),
		   rpc:call(list_to_atom(VmId++"@"++HostId),
			    init,stop,[]),
		   timer:sleep(300),
%		   io:format("rm -rf VmId = ~p~n",[{R,VmId,?MODULE,?LINE}]),
		   {R,VmId}
    end,
    Parent!{self(),Result}.

node_clean(HostId,VmId)->
    % Read computer info 
    case db_computer:read(HostId) of
	[]->
	    {error,[eexists,HostId]};
	[{HostId,User,PassWd,IpAddr,Port}]->
	    ok=my_ssh:ssh_send(IpAddr,Port,User,PassWd,"rm -rf "++VmId,2*?TimeOut)
%	    io:format("VmId = ~p",[{VmId,?MODULE,?LINE}])
	  
    end,
    ok.

%create_start(HostId,AllVmIds)->
%    AllVms=[list_to_atom(VmId++"@"++HostId)||VmId<-AllVmIds],
%    [os:cmd("mkdir "++VmId)||VmId<-AllVmIds],
%    start_vm(AllVmIds,[]),
%    R=[net_adm:ping(Vm)||Vm<-AllVms],
%    io:format("~p~n",[R]),
    

start_vm([],R)->
    R;
start_vm([VmId|T],Acc)->
    R2=os:cmd("erl -detached -setcookie abc -sname "++VmId),
    HostId=net_adm:localhost(),
    R1=check_started(100,list_to_atom(VmId++"@"++HostId),20,{error,VmId}),
%    io:format("~p~n",[{?MODULE,?LINE,VmId,R1,R2}]),
    start_vm(T,[{R1,R2}|Acc]).

check_started(_N,_Vm,_Timer,ok)->
    ok;
check_started(0,_Vm,_Timer,Result)->
    Result;
check_started(N,Vm,Timer,_Result)->
    NewResult=case net_adm:ping(Vm) of
		  pong->
		      ok;
		  Err->
		      timer:sleep(Timer),
		      {error,[Err,Vm]}
	      end,
    check_started(N-1,Vm,Timer,NewResult).













system_start()->
    
    AllVmIds= lists:append([?ControlVmIds,?EtcdVmIds,?WorkerVmIds]),
  

    % clean computer rm -rf service
    HostId=net_adm:localhost(),
    ControlVms=[list_to_atom(VmId++"@"++HostId)||VmId<-?ControlVmIds],
    EtcdVms=[list_to_atom(VmId++"@"++HostId)||VmId<-?EtcdVmIds],
    WorkerVms=[list_to_atom(VmId++"@"++HostId)||VmId<-?WorkerVmIds],
    AllVms=lists:append([ControlVms,EtcdVms,WorkerVms]),
    AllVmIds= lists:append([?ControlVmIds,?EtcdVmIds,?WorkerVmIds]),

    %Stop detached vms and delete dirs
   % [rpc:call(Vm,init,stop,[])||Vm<-AllVms],
   % [os:cmd("rm -rf "++VmId)||VmId<-AllVmIds],
    
    % create dirs and start vms
    [os:cmd("mkdir "++VmId)||VmId<-AllVmIds],
 
    start_vm(AllVmIds,[]),
    R=[net_adm:ping(Vm)||Vm<-AllVms],
    io:format("~p~n",[R]),
    
    % start dbase_service 
     io:format("~p~n",[application:start(dbase_service)]),
    
    % clone include
    % Node_service
    % clone dbase 
    % clone 
    ?assertMatch({pong,_,_},dbase_service:ping()),
    timer:sleep(500),
    ok.
